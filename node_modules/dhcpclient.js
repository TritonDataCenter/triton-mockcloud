
var assert = require('assert');
var broadcastAddr = '255.255.255.255';
var dgram = require('dgram');
var in_flight = {};
var socket;
var DHCPPacket = require('dhcp').DHCPPacket;

function buildDHCPDISCOVER(mac, uuid)
{
    var discover_opts = [];
    var xid;

    // The following option values came from a DHCP request from a SmartOS GZ
    discover_opts[53] = [ 0x01 ];
    discover_opts[55] = [
        0x01, 0x02, 0x03, 0x05, 0x06, 0x0b, 0x0c, 0x0d,
        0x0f, 0x10, 0x11, 0x12, 0x2b, 0x36, 0x3c, 0x43,
        0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87
    ];
    discover_opts[57] = [ 0x04, 0xec ];
    discover_opts[60] = [
        0x50, 0x58, 0x45, 0x43, 0x6c, 0x69, 0x65, 0x6e,
        0x74, 0x3a, 0x41, 0x72, 0x63, 0x68, 0x3a, 0x30,
        0x30, 0x30, 0x30, 0x30, 0x3a, 0x55, 0x4e, 0x44,
        0x49, 0x3a, 0x30, 0x30, 0x32, 0x30, 0x30, 0x31
    ];
    discover_opts[93] = [ 0x00, 0x00 ];
    discover_opts[94] = [ 0x01, 0x02, 0x01 ];

    // remove '-' from uuid then split to component bytes and prepend w/ 0x00
    // to generate the UUID option as specified in RFC 4578.
    discover_opts[97] = [0x00];
    uuid.replace(/-/g,'').match(/.{1,2}/g).forEach(function (digit) {
        discover_opts[97].push(parseInt(digit, 16));
    });

    // generate a 4 byte XID based on the time
    xid = Math.floor((new Date().getTime() / 100) % 2147483647);

    return (new DHCPPacket(
        1, // op (DHCPDISCOVER)
        1,  // htype
        6, // hlen
        0, // hops
        xid, // xid
        0, // secs
        0, // flags
        0, // ciaddr
        0, // yiaddr
        0, // siaddr
        0, // giaddr
        mac, // chaddr
        '', // sname
        '', // file
        discover_opts
    ));
};

/*
 * XXX do I need to do DHCPREQUEST too?
 */

// XXX track sent packets by what we expect to receive
// write handler function that calls callback when we receive it


function arrayToHex(input) {
    var res = '';

    assert(Array.isArray(input));
    assert(input.length > 0);

    input.forEach(function (num) {
        res = res + num.toString(16);
    });

    return res;
}

function intToIP(integer) {

    var octets = [];

    for (var i=0; i < 4; i++) {
        octets[i] = integer << (i * 8) >> 24;
    }

    return octets.join('.');
}

function sendPacket(packet, callback) {
    var rawpacket;

    in_flight[packet.chaddr,packet.xid] = callback;

    rawpacket = packet.raw();
    socket.send(rawpacket, 0, rawpacket.length, 67, broadcastAddr,
        function (err, bytes) {
        if (err) {
            console.error(err, 'Error sending packet for "%s": %s', packet.chaddr, err.message);
        } else {
            console.log('Sent packet for "%s" (%d bytes)', packet.chaddr, bytes);
        }
    });
}

function setupSocket() {

    // 'socket' is global, here we will set it up only if it's not been setup.
    if (socket) {
        return;
    }

    socket = dgram.createSocket('udp4', function (msg, peer) {
        // called when we get a response
        var packet = DHCPPacket.parse(msg);
        if (in_flight[packet.chaddr,packet.xid]) {
            in_flight[packet.chaddr,packet.xid](packet);
            delete in_flight[packet.chaddr,packet.xid];
        }
        // console.dir(msg);
        // console.dir(peer);
    });
    socket.bind(68, '0.0.0.0');
}

function getIP(mac, uuid, callback) {
    var discover;

    // setup the dgram socket if we haven't already
    setupSocket();

    discover = buildDHCPDISCOVER(mac, uuid);
    sendPacket(discover, function (packet) {
        var result = {};

        // console.dir(packet.dump());
        result.ip = intToIP(packet.yiaddr);
        result.netmask = packet.options['1'].join('.');

        callback(null, result);
    });
}

module.exports = {
    getIP: getIP
};


/* Usage Example:
 *
 * getIP('84:2b:2b:61:ba:13', '6b69748e-50ed-11e3-9d18-bb094c575f18', function (err, result) {
 *     console.dir(result);
 * });
 *
 */
